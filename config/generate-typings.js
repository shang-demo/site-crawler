'use strict';
const Promise = require('bluebird');
const path = require('path');
const fs = Promise.promisifyAll(require('fs'));

const projectPath = path.join(__dirname, '../');
const serverPath = path.join(projectPath, 'src');
const autoGenerateDir = path.join(projectPath, 'config/typings/');
const autoGeneratePath = path.join(projectPath, 'config/typings/shang-auto-generate.d.ts');

const ideaPath = path.join(projectPath, '.idea');
const jsLibraryMappingsXmlPath = path.join(ideaPath, 'jsLibraryMappings.xml');
const jsLibraryMappingsXmlLocalDataPath = path.join(__dirname, 'data/jsLibraryMappings.xml');
const librariesPath = path.join(ideaPath, 'libraries');
const librariesLocalDataPath = path.join(__dirname, 'data/libraries/shang_auto_generate.xml');
const librariesName = 'shang_auto_generate.xml';

function filePathOneLayer(modelsPath) {
  return Promise
    .try(function () {
      return fs.readdirAsync(modelsPath);
    })
    .then(function (fileNames) {
      return Promise.map(fileNames, function (fileName) {
        var filePath = path.join(modelsPath, fileName);

        var extname = path.extname(filePath);
        if (extname !== '.js') {
          return null;
        }

        return fs.statAsync(filePath)
          .then(function (stat) {
            return {
              basename: fileName.replace(/\.js/i, ''),
              name: fileName,
              path: filePath,
              stat: stat
            };
          });
      })
        .filter(function (file) {
          return file && file.stat && file.stat.isFile();
        });
    });
}

function ensureTypingDir() {
  return fs.mkdirAsync(autoGenerateDir)
    .catch(function (e) {
      if (e.code === 'EEXIST') {
        return Promise.resolve();
      }
      return Promise.reject(e);
    });
}

function getServicesDeclare() {
  return filePathOneLayer(path.join(serverPath, 'services'))
    .map(function (serviceFile) {
      return 'declare let ' + serviceFile.basename + ' = global.' + serviceFile.basename + ';';
    }).then(function (arr) {
      return arr.join('\n');
    });
}

function getModelsDeclare() {
  return filePathOneLayer(path.join(serverPath, 'models'))
    .map(function (modelFile) {
      return 'declare let ' + modelFile.basename + ' = require(\'mongoose\').Model;';
    }).then(function (arr) {
      return arr.join('\n');
    });
}

function getGlobal() {
  return Promise
    .try(function () {
      return 'declare let _ = require(\'lodash\');\ndeclare let Promise = require(\'bluebird\');\n';
    });
}

function getErrors() {
  let errors = require(path.join(serverPath, 'config/errors')).errors;
  let str = 'let Errors: {\n  OperationalError(): void,';

  return Promise
    .map(Object.keys(errors), function (key) {
      return '  ' + key + '(): Error,';
    })
    .then(function (arr) {
      return str + '\n' + arr.join('\n') + '\n}\ndeclare let Errors: Errors;';
    });
}

function getMKoa() {
  return Promise
    .try(function () {
      return '\ndeclare let mKoa = {\n  config: require(\'config\'),\n  environment: {}\n};\n';
    });
}

function globalLogger() {
  return Promise
    .try(function () {
      return 'declare let logger = require(\'pino\')();';
    });
}

function fsPromisifyAll() {
  return Promise.try(() => {
    return `
let Buffer = require('node').Buffer;
declare let  fs: {
  renameAsync(oldPath: string, newPath: string): Promise<void>;
  truncateAsync(path: string | Buffer, len?: number): Promise<void>;
  ftruncateAsync(fd: number, len?: number): Promise<void>;
  chownAsync(path: string | Buffer, uid: number, gid: number): Promise<void>;
  fchownAsync(fd: number, uid: number, gid: number): Promise<void>;
  lchownAsync(path: string | Buffer, uid: number, gid: number): Promise<void>;
  chmodAsync(path: string | Buffer, mode: string | number): Promise<void>;
  fchmodAsync(fd: number, mode: string | number): Promise<void>;
  lchmodAsync(path: string | Buffer, mode: string | number): Promise<void>;
  statAsync(path: string | Buffer): Promise<fs.Stats>;
  lstatAsync(path: string | Buffer): Promise<fs.Stats>;
  fstatAsync(fd: number): Promise<fs.Stats>;
  linkAsync(srcpath: string | Buffer, dstpath: string | Buffer): Promise<void>;
  symlinkAsync(srcpath: string | Buffer, dstpath: string | Buffer, type?: string): Promise<void>;
  readlinkAsync(path: string | Buffer): Promise<string>;
  realpathAsync(path: string | Buffer): Promise<string>;
  unlinkAsync(path: string | Buffer): Promise<void>;
  rmdirAsync(path: string | Buffer): Promise<void>;
  mkdirAsync(path: string | Buffer, mode?: string | number): Promise<void>;
  readdirAsync(path: string | Buffer): Promise<string[]>;
  closeAsync(fd: number): Promise<void>;
  openAsync(path: string | Buffer, flags: string | number, mode?: number): Promise<number>;
  utimesAsync(path: string | Buffer, atime: number | Date, mtime: number | Date): Promise<void>;
  futimesAsync(fd: number, atime: number | Date, mtime: number | Date): Promise<void>;
  fsyncAsync(fd: number): Promise<void>;
  writeAsync(fd: number, data: string, position?: number, encoding?: string): Promise<[number, string]>;
  writeAsync(fd: number, buffer: Buffer, offset: number, length: number, position?: number): Promise<[number, Buffer]>;
  readAsync(fd: number, buffer: Buffer, offset: number, length: number, position: number): Promise<[number, Buffer]>;
  readFileAsync(file: string | number | Buffer, options?:
             { encoding?: "buffer" | null; flag?: string; }
             | "buffer"
             | null): Promise<Buffer>;
  readFileAsync(file: string | number | Buffer, options: { encoding: string; flag?: string; } | string): Promise<string>;
  writeFileAsync(file: string | number | Buffer, data: string | Buffer, options?:
              { encoding?: string | null; mode?: string | number; flag?: string; }
              | string
              | null): Promise<void>;
  appendFileAsync(file: string | number | Buffer, data: string | Buffer, options?:
               { encoding?: string | null; mode?: number | string; flag?: string; }
               | string
               | null): Promise<void>;
  existsAsync(path: string): Promise<boolean>;
  accessAsync(path: string, mode?: number): Promise<void>;
  copyAsync(src: string, dest: string, options?: {overwrite: boolean, errorOnExist: boolean, dereference: boolean, preserveTimestamps: boolean, filter: Function});
  emptyDirAsync(dir: string);
  emptydirAsync(dir: string);
  ensureFileAsync(file: string);
  createFileAsync(file: string);
  ensureDirAsync(dir: string);
  mkdirsAsync(dir: string);
  mkdirpAsync(dir: string);
  ensureLinkAsync(srcpath: string, dstpath: string);
  ensureSymlinkAsync(srcpath: string, dstpath: string, type: string);
  moveAsync(src: string, dest: string, options?: {overwrite: boolean});
  outputFileAsync(file: string, data: string|Buffer|Uint8Array, options?: Object | string);
  outputJsonAsync(file: string, object:Object, options?: Object);
  readJsonAsync(file: string, options:Object);
  removeAsync(path: string);
  writeJsonAsync(file: string, object:Object, options?: Object);
  writeJSONAsync(file: string, object:Object, options?: Object);
};
`
  });
}

function init() {
  return ensureTypingDir()
    .then(function () {
      return Promise
        .all([
          getGlobal(),
          getErrors(),
          globalLogger(),
          getModelsDeclare(),
          getServicesDeclare(),
          fsPromisifyAll(),
          getMKoa()
        ]);
    })
    .then(function (arr) {
      return fs.writeFileAsync(autoGeneratePath, arr.join('\n'));
    })
    .then(function () {
      return replaceJsLibraryMappings();
    });
}

function addToIml(file) {
  var str = `<orderEntry type="library" name="shang-auto-generate" level="project" />`;

  return fs.readFileAsync(file.path)
    .then(function (buffer) {
      var data = buffer.toString();
      data = data.replace(str, '');
      data = data.replace('</component>', `  ${str}\n  </component>`);

      return fs.writeFileAsync(file.path, data);
    });
}

function replaceJsLibraryMappings() {
  return Promise
    .try(() => {
      return fs.readFileAsync(jsLibraryMappingsXmlPath)
        .catch(function (e) {
          return fs.readFileAsync(jsLibraryMappingsXmlLocalDataPath);
        });
    })
    .then(function (buffer) {
      var data = buffer.toString();
      data = data.replace(/\s*<file url="file:\/\/\$PROJECT_DIR\$\/src" libraries="{shang-auto-generate}" \/>\n/g, '');
      data = data.replace(/,\s*shang-auto-generate/gi, '');
      data = data.replace(`<component name="JavaScriptLibraryMappings">`, `<component name="JavaScriptLibraryMappings">\n    <file url="file://$PROJECT_DIR$/src" libraries="{shang-auto-generate}" />\n`);
      return fs.writeFileAsync(jsLibraryMappingsXmlPath, data);
    })
    .then(function () {
      return fs.mkdirAsync(librariesPath)
        .catch(function () {
        });
    })
    .then(function () {
      return fs.readFileAsync(librariesLocalDataPath);
    })
    .then(function (data) {
      return fs.writeFileAsync(path.join(librariesPath, librariesName), data);
    })
    .then(function () {
      return getNameMatchPath(ideaPath, /\.iml$/);
    })
    .then(function (file) {
      return addToIml(file);
    });
}

function getNameMatchPath(rootPath, reg) {
  return Promise
    .try(() => {
      return fs.readdirAsync(rootPath);
    })
    .map((fileName) => {
      let filePath = path.join(rootPath, fileName);

      return fs
        .lstatAsync(filePath)
        .then((stats) => {
          return {
            basename: fileName.replace(/\.js/i, ''),
            name: fileName,
            path: filePath,
            stats,
          };
        });
    })
    .filter((file) => {
      return file.stats && file.stats.isFile() && reg.test(file.name);
    })
    .then(function (arr) {
      return arr[0];
    });
}

if (process.argv && process.argv[2] && process.argv[2] === 'init') {
  init();
}

module.exports = {
  init,
};
